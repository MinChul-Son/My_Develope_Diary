# 싱글톤 컨테이너(Singleton Container)

## 왜 싱글톤을 사용하는가?
* 싱글톤을 사용하는 근본적인 이유에 대해 먼저 알아야한다.
![image](https://user-images.githubusercontent.com/60773356/120155941-5e37d900-c22c-11eb-97ed-f3063c7e596a.png)
* 이러한 스프링 빈이 존재한다고 가정해보자.
* 이 스프링 빈은 요청이 들어올 때마다 항상 새로운 객체를 만들어 반환해주게된다.
* 즉, 고객의 요청 1000번이 들어오면 객체 1000개가 생성된다!!
* JVM메모리에 요청이 들어올 때 마다 객체가 생성되어 올라간다. ==> 굉장한 메모리 낭비
* 요청의 수(고객의 수)가 많아질 수록 메모리의 낭비가 기하급수적으로 심해진다.


## 싱글톤 패턴
* 클래스의 인터스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
* 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
  - private 생성자를 사용하여 외부에서 임의로 new 키워드를 사용하지 못하게 해야함.
* 여기에는 Java의 static이라는 개념이 필요하다. [static 참고문서](https://wikidocs.net/228)

![image](https://user-images.githubusercontent.com/60773356/120156445-f1710e80-c22c-11eb-8d56-47e2caaca16c.png)
* 이 클래스가 실행되어 JVM이 읽게되면 먼저 static영역에 instance 객체를 하나 생성한다.
* 후에 이 객체 인스턴스가 필요하면 getInstance를 통해서만 가져올 수 있다. 이는 항상 같은 인스턴스를 반환한다.
* 새로 생성하는 것이 아닌 미리 만들어두고 계속 가져다 쓰는 것
* 또한 다른 클래스에 new SingletonService()를 하지 못하도록 privte을 통하여 새로운 객체 인스턴스가 생성되는 것을 방지한다.
* Spring을 사용하게되면 알아서 Singleton Pattern을 적용하여 인스턴스를 관리해준다.

### 하지만 싱글톤 패턴에는 문제가 존재한다.
* 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
* 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP를 위반한다.
* 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
* 테스트하기 어렵다.
* 처음 1개를 생성할 때 이미 설정이 다 끝나버리기 때문에 유연하게 테스트하기 어려움
* 내부 속성을 변경하거나 초기화 하기 어렵다.
* private 생성자로 자식 클래스를 만들기 어렵다.
* 결론적으로 **유연성이 떨어진다.**(DI를 적용하기가 어려워짐)
* 안티패턴으로 불리기도 한다
* 
-----------------------
-------------------
## 싱글톤 컨테이너(=스프링 컨테이너)
#### #스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다. 
#### #스프링 빈이 바로 싱글톤으로 관리되는 빈이다. 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
#### #스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
#### #스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지한다.
* 싱글톤 패턴을 위한 지저분한 코드가 추가되지 않아도 된다.
* DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용

## ⭐중요 : 싱글톤 방식의 주의점
#### #싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
#### #무상태(stateless)로 설계해야한다.(REST API에서의 그 stateless 맞음!)
* 특정 클라이언트에 의존적인 필드가 있으면 안된다.
* 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
* 가급적 읽기만 가능해야 한다.
  - 가급적이면 수정을 하면 안된다는 의미
* 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다. [ThreadLocal](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html)

### 예시
![image](https://user-images.githubusercontent.com/60773356/120158430-16ff1780-c22f-11eb-88aa-915650c6a2a6.png)
* 위와 같이 단순히 사용자명과 주문금액을 받아 주문을 생성하는 서비스가 있다고 가정하겠다.


![image](https://user-images.githubusercontent.com/60773356/120158609-4746b600-c22f-11eb-92b5-47f183e20aeb.png)
* 이를 임시 설정파일 TestConfig를 통하여 스프링 컨테이너에 등록시킨다. ==> Singleton 방식 사용
* 그 후 서로 다른 객체에서 빈을 꺼내면 같은 인스턴스 객체가 반환될 것이다.

![image](https://user-images.githubusercontent.com/60773356/120158702-62b1c100-c22f-11eb-9c9c-fbac3020ff6e.png)
* 각각 다른 사용자가 다른금액의 물품을 주문하였다.
* 그 후 사용자 A가 주문한 금액을 출력해보면 10000원이 나와야하지만 사용자 B, 즉 다른 Thread에 의해 이미 값이 변경되었기 때문에 20000원이 출력된다.
* 이것이 바로 **동시성 문제**이다!!
  - 동시성 문제란 두 개 이상의 세션이 공통된 자원에 대해 모두 읽고 쓰는 작업(Read→Write) 을 하려고 하는 경우 발생할 수 있는 문제를 말한다.

#### **공유 필드는 굉장히 조심해야함. 스프링 빈은 항상 무상태(Stateless)로 설계**

#### 예제에서 발생한 동시성 문제 해결법(지역 변수 사용하기)
![image](https://user-images.githubusercontent.com/60773356/120158997-b02e2e00-c22f-11eb-816e-0e079d5b036c.png)
* 공유되는 필드를 없애고 바로 return시켜 지역변수로써 사용하게 한다.

![image](https://user-images.githubusercontent.com/60773356/120159027-b91eff80-c22f-11eb-9b9f-af3403c24bda.png)
![image](https://user-images.githubusercontent.com/60773356/120159042-bc19f000-c22f-11eb-8af1-38c1ab0e9353.png)
* 반환된 값을 각각의 지역변수에 저장하여 사용하면 정상적으로 고객에 따른 주문금액을 뽑아낼 수 있다.

### 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다. 굉장히 중요한 개념이니 숙지하자!!




















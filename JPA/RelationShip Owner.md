# 연관관계 주인
### 엔티티 vs 테이블
* OneToOne = 1 : 1
* OneToMany = 1 : N
* ManyToOne = N : 1
* ManyToMany = N : M
  - 실제로 ManyToMany(다대다)관계는 사용해선 안된다.
  - 중간 테이블에 컬럼을 추가할 수 없고, 세밀하게 쿼리를 실행하기 어렵기 때문에 한계가 있다.
  - 다대다 관계를 사용할 때는 중간 엔티티를 만들어 ManyToOne + OneToMany로 관계를 매핑한다.


## Example) 회원과 주문
### 1. 엔티티
![image](https://user-images.githubusercontent.com/60773356/119074244-a6374e80-ba29-11eb-9181-070a9bc3d7e0.png)
### 2. 테이블
![image](https://user-images.githubusercontent.com/60773356/119074276-b2231080-ba29-11eb-8bcb-3983c0ecc728.png)
   
* 엔티티에서는 Member가 orders라는 주문 리스트를 가지고 있지만, 실제 MEMBER 테이블에서는 외래키를 관리하지 않는다. 
* 다만 ORDERS에 있는 MEMBER_ID라는 외래키를 통해 조인하여 조회할 뿐이다. 
* 엄밀히 이야기하면 **객체에는 양방향 연관관계라는 것이 없다.** 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐 
* 반면에 DB 테이블은 외래 키 하나로 양쪽이 서로 조인할 수 있다. 따라서 테이블은 외래 키 하나만으로 양방향 연관관계를 맺는다.
* 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나이다. 따라서 둘 사이에 차이가 발생한다. 
* 그렇다면 둘 중 어떤 관계를 사용해서 외래 키를 관리해야 할까?
* JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 **연관관계의 주인**이라 한다.

#### 결론적으로, 외래키가 있는 곳을 연관관계의 주인으로 정하면 된다.
* DB에서 일대다 관계가 존재한다면 외래키는 항상 다쪽에 존재한다. 따라서 외래키가 있는 다쪽을 연관관계의 주인으로 정하는 것이다. 
* 그렇지 않다면, MEMBER에서 관리하지 않는 ORDER 테이블의 외래 키 값이 업데이트 되므로 관리와 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 발생함. 

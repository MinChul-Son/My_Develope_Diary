# 트랜잭션
* [영상 링크](https://www.youtube.com/watch?v=e9PC0sroCzc&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9CTech)
* 예지니어스님의 10분 테코톡을 보고 작성되었습니다.


#### 스프링을 사용하다보면 @Transactional 애노테이션을 많이 사용하는데 트랜잭션이 뭘까?

## 트랜잭션이란?
* 여러 쿼리를 논리적으로 하나의 작업으로 묶어주는 것
### Example
* 거래 과정
  - 구매자의 계좌에서 10000원 출금
  - 판매자 계좌에 10000원 입금
* 거래가 일어날 때 실행되는 쿼리
  - UPDATE문 : 구매자의 계좌에서 10000원 빼기
  - UPDATE문 : 판매자의 계좌에 10000원 더하기
* 서버에 문제가 발생해 구매자의 계좌에서는 10000원이 빠져나갔지만 판매자의 계좌에는 10000원이 들어오지 않는 문제가 발생할 수 있다.
* 이를 방지하기 위한 것이 **트랜잭션**이다.
### 트랜잭션
* 쿼리를 논리적으로 하나로 묶어 한번에 모두 실행되거나 모두 실행되지 않도록 한다.
* 따라서 DB가 데이터를 안정적으로 보장할 수 있도록 한다.

### Commit & Rollback
* 커밋은 일종의 확인 조작으로 트랜잭션으로 묶인 모든 쿼리가 성공되어 트랜잭션 쿼리 결과를 실제 DB에 반영하는 것
* 롤백은 쿼리 실행을 취소하고 DB상태를 트랜잭션 이전의 상태로 되돌리는 것
* 
--------------------------------
## 트랜잭션의 성질 : ACID
* 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
* A : Atomicity(원자성)
  - 트랜잭션은 DB에 모두 반영되거나, 전혀 반영되지 않아야한다.
  - 완료되지 않은 트랜잭션의 중간 상태를 DB에 반영해서는 안된다.
* C : Consistency(일관성)
  - 트랜잭션 작업처리 결과는 항상 일관성이 있어야 한다.
  - DB는 항상 일관된 상태로 유지되어야 한다.
  - DB가 여러 제약조건에 맞는 상태를 보장해준다.  
* I : Isolation(독립성)
  - 둘 이상의 트랜잭션이 동시에 실행될 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
  - 각각의 트랜잭션은 서로 간섭없이 독립적으로 이루어져야 한다.  
* D : Durability(지속성)
  - 트랜잭션이 성공적으로 완료되었으면 결과는 영구적으로 반영되어야 한다.

### 성능의 문제
* 실제로는 성능을 위해 성질 보장이 완화되기도 한다.
* 즉, 완벽히 성질을 보장하려면 성능이 떨어질 수 있음.
  - ex : 동일 데이터에 여러개의 접근이 발생했을 때 독립성을 완벽히 보장하기 위해 하나씩 순차적으로 처리해야함 --> 성능 저하(동시성 저하)
### 트랜잭션 격리 수준
* 동시성을 얻기 위한 한 가지 방법이다.
* 동시어 DB에 접근할 때 그 접근을 어떻게 제어할지에 대한 설정
![image](https://user-images.githubusercontent.com/60773356/125926001-2df6ece8-c301-44a9-8bce-1859e5388788.png)
* 아래로 갈 수록 격리 수준이 높아지지만 성능이 떨어짐(데이터 정합성과 성능은 반비례)
* 위로 갈 수록 격리 수준은 낮아지지만 동시성은 높아진다.
#### READ-UNCOMMITTED
![image](https://user-images.githubusercontent.com/60773356/125926538-e8b5b49e-0c8c-4b64-bb9c-370c61420951.png)
* 커밋 전의 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 읽는 것을 허용  
* 여기서는 **Dirty Read** 문제가 발생할 수 있다.
* 위의 그림에서 트랜잭션1이 롤백되어도 이미 트랜잭션2는 값을 읽은 상태이기 때문에 문제가 발생할 수 있다.

#### READ-COMMITTED
![image](https://user-images.githubusercontent.com/60773356/125927098-4f8fb5dc-7426-409a-96bd-10e1c7229312.png)
* 커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회 가능
* 커밋된 데이터만을 읽기 때문에 Dirty Read 문제는 발생하지 않는다.
* 하지만 이 격리 수준 이하에서는 **Non-Repeatable Read** 가 발생한다.
* 하나의 트랜잭션에서 같은 값을 조회할 때 다른 값이 검색되는 현상을 말한다.
* 트랜잭션1이 커밋되기 이전과 커밋 이후의 조회 값이 서로 다르게 조회된다.

#### REPEATABLE-READ
![image](https://user-images.githubusercontent.com/60773356/125927838-b0863c6f-6dee-4dd7-bc03-67881c7fb20e.png)
* 마찬가지로 커밋이 완료된 데이터만 읽을 수 있지만 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장해준다.
* 데이터를 변경하려고 하면 UNDO 영역에 백업해두고 실제 레코드를 변경하게 된다.
* 이 격리 수준에서는 **Phantom Read** 문제가 발생한다.
* UPDATE한 데이터에 대해서는 정합성을 보장하지만, INSERT/DELETE는 보장되지 않기 때문에 발생하는 문제이다.
* 있던 데이터가 없어지거나 없던 데이터가 생기는 현상(마치 귀신을 본 것 처럼 ==> 그래서 Phantom)
* 그림에서 트랜잭션1이 트랜잭션2가 커밋한 새로운 데이터를 조회한 뒤에 트랜잭션2가 롤백된다면 이미 조회했던 데이터이지만 다시 조회한다면 롤백으로 인해 보이지 않게 되는 것이다.

#### SERIALIZABLE
* 한 트랜잭션에서 사용하는 데이터를 다른 트랜잭션에서 접근 불가
* 가장 강력하게 트랜잭션 성질을 보장해주지만 성능은 가장 떨어진다.

------------------------------------
## 트랜잭션 전파 타입
* 트랜잭션의 경계에서 트랜잭션이 어떻게 동작할 것인가?
* 트랜잭션 안에서 또 다른 트랜잭션이 처리되는 경우
```java
public class ServiceA {
  private ServiceB serviceB;
  .....
  
  @Transactional
  public void a() {
    serviceB.b();
  }
}

public class ServiceB {
  @Transactional
  public void b() {..}
}
```
![image](https://user-images.githubusercontent.com/60773356/125929942-8e88efb9-ed94-4b07-b792-26d90445c8bb.png)
### 스프링에서 제공하는 Isolation 열거 타입에 정의된 값
![image](https://user-images.githubusercontent.com/60773356/125930205-0c87d063-7c24-4ecf-aac6-c0c15a70d6b5.png)
### 스프링에서 제공하는 Propagation 열거 타입에 정의된 값
![image](https://user-images.githubusercontent.com/60773356/125930317-757c0843-e5e0-4bcb-b714-1d6f78c8ba5d.png)
